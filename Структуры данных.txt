List<T> - масштабируемый массив. Позволяет быстро получать доступ к произвольным элементам и добавлять в конец массива (O(1), если ещё есть место в массиве. O(n), если места в массиве нет.), но при этом сложнее удалять/добавлять элементы в произвольные места массива. Надо передвигать все последующие элементы.

LinkedList<T> - связанный список. Быстрый последовательный доступ (в том числе для добавления и удаления элементов) O(1) с начала или конца списка, а так же с любого элемента для которого уже есть LinkedListNode<T> объект.
Недостатки - для каждого элемента нужен отдельный объект (больше потребление и операций выделения памяти). Сложность доступа к произвольным элементам. Надо проходить по списку для поиска.

ObservableCollection<T> - Применяется там, где нужно наличие событий при изменении коллекции.

HashSet<T>, SortedSet<T> - применяются тогда, когда надо хранить уникальные значения и/или производить операции объединения, пересечения и т. д. над набором уникальных значений. Такие операции, а так же проверка наличия значения в наборе, происходит быстрее, чем, например, в List<T>.
HashSet<T> хранит данные в произвольном порядке. SortedSet<T> хранит данные в отсортированном порядке. Поэтому SortedSet<T> нужен тогда, когда данные должны быть отсортированы, хотя это снижает скорость обработки.

Dictionary<TKey, TValue> - позволяет получать доступ к данным с использованием уникального ключа. Так же как и HashSet<T> обладает большой скоростью проверки наличия ключа. Применяется там, где в качетсве индекса надо использовать произвольный тип данных. Несколько медленнее, чем использование, например, List<T> с целочисленными ключами.

Queue<T> - используется там, где элементы добавляются для обработки в конец списка, а берутся - из начала.

Stack<T> - используется там, где для обработки сначала берётся последний добавленный элемент. Например, сохранение состояния чего-либо для последующей отмены изменения, начиная с последних изменений.